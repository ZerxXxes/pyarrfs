#!/usr/bin/env python
#
# Copyright (c) 2010 Kristian Larsson <kristian@spritelink.net>
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
#
# Check out http://labs.spritelink.net/pyarrfs for the latest version of this
# software.
#

import os, sys
import errno
import fcntl
import re
import stat

import fuse
import rarfile

fuse.fuse_python_api = (0, 2)

fuse.feature_assert('stateful_files', 'has_init')

import syslog
# debug print
def dPrint(message):
    debug = 0
    if debug is not None and debug > 0:
        syslog.syslog(message)

class Pyarr(fuse.Fuse):
    def __init__(self, *args, **kw):
        fuse.Fuse.__init__(self, *args, **kw)
        self.root = '/'

    def fsinit(self):
        os.chdir(self.root)




    def access(self, path, mode):
        """Returns whether a user has access to performing 
        """
        dPrint("access -- " + path)

        # test for write access, PyarrFS is incapable of do writes, so no axx
        if mode == os.W_OK:
            return -EACCES

        # allow the rest
        # FIXME: do more granular access control, based on RAR file?
        return

        # this only works for files not inside a rar archive
        if not os.access("." + path, mode):
            return -EACCES

    def getattr(self, path):
        dPrint("getattr -- " + str(path))
        if re.match('.*\.rar$', path):
            dPrint("getattr: on rar archive for path " + str(path))
            original_stat = os.lstat("." + path)
            fake_stat = fuse.Stat()
            fake_stat.st_mode = stat.S_IFDIR | 0755
            fake_stat.st_ino = 0
            fake_stat.st_dev = 0
            fake_stat.st_nlink = 2
            fake_stat.st_uid = original_stat.st_uid
            fake_stat.st_gid = original_stat.st_gid
            fake_stat.st_size = 4096
            fake_stat.st_atime = original_stat.st_atime
            fake_stat.st_mtime = original_stat.st_mtime
            fake_stat.st_ctime = original_stat.st_ctime
            dPrint("getattr: returning fake_stat for " + str(path))
            return fake_stat

        elif re.match('.*\.rar/.+', path):
            dPrint("getattr: we need to check inside rar archive for path " + str(path))
            m = re.match('(.*\.rar)/(.+)', path)
            rar_file = m.group(1)
            rar_path = m.group(2)

            original_stat = os.lstat("." + rar_file)
            rf = rarfile.RarFile(rar_file, 'r', None, None, False)
            try:
                rfi = rf.getinfo(rar_path)
            except:
                # FIXME: add DEBUG log entry
                return -errno.ENOENT

            fake_stat = fuse.Stat()
            fake_stat.st_mode = stat.S_IFREG | 0444
            fake_stat.st_ino = 0
            fake_stat.st_dev = 0
            fake_stat.st_nlink = 1
            fake_stat.st_uid = original_stat.st_uid
            fake_stat.st_gid = original_stat.st_gid
            fake_stat.st_size = rfi.file_size

            import datetime
            (rft_year, rft_month, rft_day, rft_hour, rft_minute, rft_second) = rfi.date_time
            rft_time = datetime.datetime(rft_year, rft_month, rft_day, rft_hour, rft_minute, rft_second)
            fake_stat.st_atime = int(rft_time.strftime('%s'))
            fake_stat.st_mtime = int(rft_time.strftime('%s'))
            fake_stat.st_ctime = int(rft_time.strftime('%s'))
            dPrint("getattr: returning fake_stat for " + str(rar_path) + " inside rar " + str(rar_file))
            return fake_stat
     
        dPrint("getattr: returning normal os.lstat() for path " + str(path))
        return os.lstat("." + path)

    # get a directory listing
    # doesn't need changes in yarrfs compatibility mode
    def readdir(self, path, offset):
        dPrint("readdir -- path: " + str(path) + "  offset: " + str(offset) )
        dirent = [ '.', '..' ]

        if re.match('.*\.rar$', path):
            dPrint("readdir: on rar archive, using rarfile")
            rf = rarfile.RarFile(path, 'r', None, None, False)
            for e in rf.namelist():
                dirent.append(str(e))
        else:
            dPrint("readdir: normal dir, using os.listdir()")
            try:
                os.listdir("." + path)
            except:
                return

            for e in os.listdir("." + path):
                dirent.append(e)

        for e in dirent:
            yield fuse.Direntry(e)


    def readlink(self, path):
        dPrint("readlink -- " + path)
        return os.readlink("." + path)

    def statfs(self):
        dPrint("statfs -- " + path)
        return os.statvfs(".")


    class PyarrFile(object):
        def __init__(self, path, flags, *mode):
            # Enabling direct_io disables the kernels page cache.
            # Since the content of our RAR files should be pretty stable, we do
            # NOT enable this, ie we allow the kernel to cache all data.
            # This means we get both the .rar file and the file inside the RAR 
            # archive in the block cache which might affect performance 
            # negatively. On the other hand, the kernel could purge the .rar 
            # file from its block cache and just keep the inside file. 
            # It's likely mostly a performance thing. I'm guessing it's good
            # to let the kernel decide on what to cache and what not too, so we
            # set it to False. Some benchmarking should really be done to prove
            # either setting is better than the other
            self.direct_io = False
            # keep_cache means the kernel is allowed to cache content of a file
            # after its been closed an reopened. You only want to disable this
            # if the content of the file might change without the kernel knowing
            # about it, which would be typical for a networked file system.
            # That's not the case with PyarrFS so we enable it.
            self.keep_cache = True
            m = re.match('(.*\.rar)/(.+)', path)
            self.rar_file = m.group(1)
            self.rar_path = m.group(2)
            self.rf = rarfile.RarFile(self.rar_file, 'r', None, None, False)
            self.file = self.rf.open(self.rar_path)
            self.fd = 0

        def read(self, length, offset):
            self.file.seek(offset)
            return self.file.read(length)

        def release(self, flags):
            self.file.close()


    def main(self, *a, **kw):
        self.file_class = self.PyarrFile
        return fuse.Fuse.main(self, *a, **kw)


def main():
    usage = """
PyarrFS mirror the filesystem tree from some point on, allowing RAR archives to be treated as directories and files within those RAR archives to be read as regular files.

""" + fuse.Fuse.fusage

    server = Pyarr(version="PyarrFS 0.1",
                 usage=usage)

    server.multithreaded = False
    server.parse(values=server, errex=1)

    server.main()




if __name__ == '__main__':
    main()


#
# vim: et ts=4 :
#
